---
title: "Thinking in Projects"
subtitle: "Using `fs` and friends"
description: "Increasing Portability and Reproducibility"
date: 05-20-2025
categories: [R, R-Package, Developer-Toolkit, Developer-Mindset] 
citation: 
    url: https://asenetcky.dev/using-projects
draft: true 
---

## The Premise

How many times have you seen this at the top of an R script that was shared 
with you by a friend or colleague?

```{r}
#| eval: false

setwd("~/some/path/not/on/your/computer/")

foo <- function() {
  print("AHHHH I NEED THIS TO WORK I HAVE A DEADLINE")
}

foo()

```

You need that script to run - but it just blows up spectacularly in your face. 
You go in to change that line and then the script works, or it doesn't. 
I find - more often than not - that if there is a `setwd()` at the top of a
script, that even if I correct the path there are other depedencies that did
not come along for the ride.

When I started out learning R I did this alot. I still see this quite often.
I see it from folks who have also moved well beyond the basics of R.  There is
nothing wrong with using `setwd()` or `getwd()`.  However, I find that it is
usually a signal that folks might not be thinking holistically about their code
and the greater ecosystem in which it exists.  Reproducibility might not
always be on the forefront of everyone's minds, and look, I get it - sometimes
you just need to slap something together to solve a problem so you never have
to think about it again. For all the other times (and I'd argue even for those
just-get-it-done-times) this might be one of those rare moments where doing the
more robust thing is also the easier thing to do.

The road to reproducibility winds ever onward, and while there are many facets
to making your code more reproducible, one of the easiest just about anyone
can adopt is a simple reframing of how we perceive our code.

> Our code is a project.

Even our small, simple little script is a project, inside of a what I'll
call *project-space*.  I'll define what I mean by *project* and *project-space*
and how you can use these mental costructs to think about your code. Also,
if you can afford to add another package dependency and you are programmatically
working with the file system I think the R package `fs` is worth taking a look
at.

## Defining *Project* and *Project-Space*

I'm using the these terms broadly to cast a wide net. Your Integrated 
Development Environment (IDE) may have a very concrete concept of a project
or some kind of workspace or the folder you are working in.  You should 
100% take advantage of those quality of life features, however I am being a
litte more meta than that. Your code, your logic was created to tackle a
problem. This is your project, *your solution*.

> Ideally this solution has everything it needs to stand alone

If it can stand alone, you can confidently pass it along to a teammate.
When users hardcode a file path at the top of the script, their computer 
*at that point in time*  intrinsically becomes a part of that solution. 

> *You* are not a project.

It is up to the developer to divorce themselves from the project. It needs to
be self-contained. There are many ways of doing this and a great deal
of tooling has spring up around divorcing the project from the user and the
machine the project was written on. It's also a spectrum too.  You need to be
realistic with yourself and your deadlines.  If R packages are all the way on
"reproducible" end of the spectrum - you may not have time for that level
of commitment, so you do what you can and aim to ship easy wins and build up
to the ideal in time.

So what are these easy wins? You can make code soultion aware of its
surroundings. This is where *project-space* comes into play.
Yes, your code physically exists on your machine. You are possibly staring at
one or more projects on your machine.  But you need to think beyond your
machine.  These projects can and should be able (to the best of your abilities)
exist on any number of machines.  
If you are tackling a business problem for work - you should strive to be able
to have your code run just about anywhere at work should something catastrophic
happen to your usual work computer. *project-space* is a way of thinking
about your code being everywhere and nowhere and tackling the problems in your
code in the most person-environment agnostic ways possible.

## The Easy Win

Using [`fs`](https://fs.r-lib.org/) will help to think about, and 
programmatically interact with your project-space.  It's a wonderful
package for working with files, folders and paths. The package is well
organized and has consistant names that make finding functionality
within the package a breeze. 

Interacting with files and folders is great, but it's the function
`fs::path_wd()` that I find myself using *all* the time.  You can basically
drop this function in your scripts and functions and it is probably going
to handle 98% of your project-space pathing issues, with a few exceptions.

Let's cover some basic concepts with `fs` before we finish with `fs::path_wd()`.

## Why fs over base?

It's spelled out better than I can ever state it in the 
[documentation](https://fs.r-lib.org/articles/function-comparisons.html).

The tl;dr is that consistancy is king, and it really is. I cannot 
emphasize that enough.  Nobody likes hidden surprises, much less coming 
from your behind-schedule, tech-debt-ridden past self.
If you can confidently tell what the code is going to do by just reading it.
Then your teammates are more likely to tell what that code is going to do
by just reading it, and they will thank you for it.

## Diving in

You'll be constructing alot of paths with `fs`, but thankfully
that is easy!

```{r}
#| label: paths

# few different ways, you can mix and match
fs::path("folder", "subfolder", "file", ext = "R")
fs::path("folder/subfolder/file.R")

```

Inspecting an `fs` path we'll see that it has it's own class `fs_path`.

```{r}
file_name <- "my_file"
my_path <-
  fs::path("folder/subfolder", file_name, ext = "csv")

my_path
class(my_path)
```

Some bells and whistles come along for the ride, but you can mostly think
of these as `characters` with some nice vectorized function friends.




### some context

I often find that new R users in my line of work don't organize their
work into distinct projects.  If they use the [Rstudio]() IDE
they aren't using rstudio projects with the `.Rproj` files or
workspaces in other IDEs. Using `git` will often force the
use of project folders or at least the mindset of one, but
often git isn't in use either.

I found that, while working in public health during a pandemic
that anything I may have produced in code - no matter how many times
it was relayed to me that the ask was "a one-time thing" - will
live on forever whether you want it to or not. If it provided 
some value, and even if it didn't, it became familiar and 
eventually took on a life all its own.
This is probably true in many other fields - so do yourself a favor
and make sure whatever it is you build is something that
isn't going to haunt you. Use `git` if you're able, and 
if not work in projects to organize your work. It may
not seem like setting up a project is worth it for
a quick todo - but if the ask is worth doing at all,
setup a project however your IDE of choice expects it.
It will become second nature and so fast that the
headaches they solve down the road will more than
make up for the short amount of time learning 
and setting them up.

### benefits of project spaces

So what are these benefits?  Most of the time
some background quality of life magic is happening.
In the case of Rstudio - the scripts are "aware" of
where they are so you usually no longer have use `setwd()` or
`getwd()`.  Project level settings can also be saved to
the project space. I think the biggest benefit of all
is a shift in your own mindset.

what is that shift? I don't know what to call it
so I'm making it up right now - "the zen of projects".
I probably read something like this somewhere and forgot
that this isn't my own idea. So I am so sorry if this is
someone else's idea. I am not trying to pass it off as my own.
If there are other related articles, or there is one 
where inadvertantly took that name from please reach out to me.
I will link them all here!

What is the "zen of projects"? You start to think about your
work as tiny little ecosystems, a functioning unit of work, not as a single script.
a collection of scripts and all the things you need to for your work to....well, *work*.
My mind instantly flashes back to all the organelles inside of a cell 
the mitochondria, the nucleous and all the other things I've completely
forgotten about until I wrote that very sentence above. I think `git` 
helps you get into this mindset most of all because you want folks
to be able to clone or fork your source code and be able to have it work.

Some of this might seem obvious to those in a more traditional
developer role in a more traditional developer job - but Git use is almost 
non-existent in my area of work. I *almost never* get a `README.md` or other
relevant documentation.
Code isn't thought about much other than as a means to an end in the *now*, 
and not a second thought is paid to the *future*.

So this is for my friends in public health and in government. 
I want to focus on the biggest gains for the least amount of effort. Incorporating
a project space is easy to do, becomes natural and gets folks into
this project zen that will hopefully get folks to start thinking about code reproducibility
and portability.


## why fs over base

It's spelled out right 
[here](https://fs.r-lib.org/articles/function-comparisons.html).

But the tl;dr is consistancy is king TODO....

### Why not `here`?

`fs` and `here` may overlap a little bit with `fs::path_wd()` and `here::here()`
but the focus of the packages is completely different. `here` is all about
project directory roots and `fs` has a little bit of that but the focus
is really on working in a file system on your computer.

Also, I wanted quick easy wins and I think `fs` with its `fs::path_wd()` is just
easier to use for most usecases. I think the `here` package is fantastic and 
those couple of extra [steps](https://here.r-lib.org/articles/here.html)
***will*** be necessary some of the time. `here` has really saved my bacon in
the past and you should absolutely know about it.  Most of the time though,
`fs::path_wd()` is *good enough*.

## use projects but take nothing for granted

So I went on that whole big thing about using projects, but here is the kicker,
take nothing for granted. Use absolute file paths without hardcoding absolute file paths.

but how? use `fs` and friends.

```{r}
#| label: setup-fs

# install.packages("pak")
# pak::pak("fs")
```

<!-- run in a container for final render & freeze -->

```{r}
#| label: quick-fs

library(fs)

path_home()

path_wd()

dir_tree(path_wd())
```


todo next steps
use tree
show this little folder with tree

TODO:
`here` is great - but less set it and forget - but you'll likely need in projects
with nested folders that use quarto or rmarkdown etc...

## the end part

Where to go from here? 
- renv
- git & repos
- template repos
- containers


So what about you? What have you picked up along the way
in your career that you would want new folks starting out
to know?  Anything you picked up from another field, or
even another programming language that your brought with
you to all your projects in other languages?