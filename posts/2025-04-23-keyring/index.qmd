---
title: "Managing Credentials with keyring"
subtitle: "Developer Toolkit"
description: "Simple Credential Management"
date: 04-23-2025
categories: [R, R-Package, Developer-Toolkit] 
citation: 
    url: https://asenetcky.dev/keyring
draft: true 
---

## The Problem

How many times have you needed to enter an API token or 
perhaps credentials to a service account? Have you ever seen
someone save credentials inside of a script? It happens,
I've seen it - I hate to admit it, but I've probably
done it myself.  It's easy to do when it's crunch time.
You tell yourself, you'll remove them when you're
done testing - but, gasp - it's too late, you've
mindlessly commited and pushed those changes
on up to the remote with git.  

Or maybe you're new and just getting started with
R.  You're almost certainly going to need to
inject a credential or something similiar sooner or
later. You _don't_ have to leave these in your
scripts. There is a better way!

## The Solution
There is an R package out there
that makes it just as easy _not_ to hardcode
credentials into scripts.  That package
is [`keyring`](https://keyring.r-lib.org/index.html)!

Let's take a look.


### Installing `keyring`

```{r install}
# install.packages("pak")
# pak::pak("keyring")

library(keyring)
```


### Putting `keyring` into practice

`keyring` stores credentials using the default credential
manager for your OS. `keyring` makes interacting with
the manager inside of your code fairly seamless.

```{r save-creds}
# keyring can be run interactively with pop ups
# or you set the values in code - execute the code
# and then remove those lines if anything is going to be saved

# save some useful credentials
keyring::key_set_with_value(
  service = "my-service",
  username = "my-username",
  password = "my-super-secret-password-SSSHHHH"
)
```

::: {.callout-important}
    Remember - you're just executing the code and not saving the
    free text in a real world situation.
:::

Now how would we access those credentials for later use?
`service` and `username` becomes the identifier used to 
pull these back into your environment.

```{r recall-credentials}

# if you happen to forget your services
# you can list them all out!
keyring::key_list()
```

Notice how the usernames are listed alongside the service?
Users should be aware of that if they do not want usernames
showing up in console somewhere. However, we'll exploit
that functionality later on.  All a logged in user needs to 
retrieve a credential is a service name and a username. 

:::{::: {.callout-caution}
  Typically keyrings are set per user and are thus subject to 
  whatever security is employed around the user account.  It is imperative
  that users take care to secure their accounts, otherwise
  one comprimised account can quicky spill over into others.
:::}

Let's grab that credential now.

```{r key-get}
keyring::key_get(service = "my-service", username = "my-username")
```

So the code above just prints straight to console - still not exactly 
what you would want in real life but now that can be saved to
an object and used just about anywhere. 


### Examples

Let's walk through some plausible examples:

```{r use-it}
keyring::key_set_with_value(
  service = "open data portal",
  username = "me@asenetcky.dev",
  password = "mytotallyrealpassword123"
)

# sometimes you just want to use the service name
# and the password - and the "password" may
# not even be a password per se.

keyring::key_set_with_value(
  service = "definitely real sql server connection string",
  password = "127.0.0.1"
)
```


### Helper Functions

Keyring works great for little private/internal helper functions and packages
that you might write or contribute to in your line of work. 
Why not wrap a helper function around some keyring functionality?

```{r helper-fun}
nab_service_cred <- function(service_name) {
  # check user input
  # `checkmate` is great to testing function input
  # and/or putting together unit tests in packages
  checkmate::assert_character(service_name)

  # handle global bindings
  service <- username <- NULL

  # grab email
  email <-
    keyring::key_list() |>
    dplyr::filter(service == service_name) |>
    dplyr::pull(username)

  # throw error if empty
  if (purrr::is_empty(email)) {
    rlang::abort(glue::glue("Credential not found"))
  }

  # grab password
  password <-
    keyring::key_get(
      service = service_name,
      username = email
    )

  # returned name list
  dplyr::lst(
    email,
    password
  ) |>
    # probably best to return
    # invisibily in case of unintended prints
    invisible()
}
```

This little helper can be a building block for other
functionality in your scripts or package.  Maybe
you have a process upstream that handles errors
elegantly - you can then wrap this up in
`purrr::safely()` and then handle potential errors
at your conveniance. 

```{r more-safer}

safer_nab <- purrr::safely(
  nab_service_cred,
  # set some default or placeholder values in case of errors
  otherwise = dplyr::lst(
    email = "default-or-fake@email.com",
    password = "defualt-or-fake-password.com"
  )
)
```

```{r bad-cred}
# test it out
results <- safer_nab("not-a-service")
results$result
# the show goes on!
```

```{r good-cred}
# what about our service from before?
results <- safer_nab("open data portal")
results
```

Hopefully these examples highlight how keyring can
be a great free tool to bolster security around credential
handling in code, as well a buiulding block for
helper functions that can get your team on the
same page with connections, databases, service
accounts etc...

### Cleaning up

Now we have all these fake services and credentials in 
our operating system's credential manager. How do 
user clean it all up?  `keyring` has tools for that
as well.

Users can use `keyring::key_delete()` to wipe out 
credentials they no longer want stored.

```{r cleanup}
# jog our memories about the services...
keyring::key_list()

# oh yeah - these ones.

dplyr::lst(
  "my-service",
  "open data portal",
  "definitely real sql server connection string"
) |>
  # let's borrow from our helper function
  purrr::map(
    \(serv) {
      x <- nab_service_cred(serv)
      x$name <- serv
      x
    }
  ) |>
  purrr::walk(
    \(cred) {
      name <- purrr::pluck(cred, "name")
      email <- purrr::pluck(cred, "email")
      keyring::key_delete(service = name, username = email)
    }
  )

keyring::key_list()
```

## Your turn

If you haven't already, check out `keyring` and see what 
usecases you can come up with. 