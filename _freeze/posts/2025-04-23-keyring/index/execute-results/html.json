{
  "hash": "cd527a4c7b6b426a540c3cb5aae9cfa5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Managing Credentials with keyring\"\nsubtitle: \"Developer Toolkit\"\ndescription: \"Simple Credential Management\"\ndate: 04-23-2025\ncategories: [R, R-Package, Developer-Toolkit] \ncitation: \n    url: https://asenetcky.dev/keyring\ndraft: true \n---\n\n\n\n## The Challenge\n\nHow many times have you needed to enter an API token or \nperhaps credentials to a service account? Have you ever seen\nsomeone save credentials inside of a script? It happens,\nI've seen it - I hate to admit it, but I've probably\ndone it myself.  It's easy to do when it's crunch time.\nYou tell yourself, you'll remove them when you're\ndone testing - but, gasp - it's too late, you've\nmindlessly committed and pushed those changes\non up to the remote with git.  \n\nOr maybe you're new and just getting started with\nR.  You're almost certainly going to need to\ninject a credential or something similar sooner or\nlater. You _don't_ have to leave these in your\nscripts. There is a better way!\n\n## The Solution\nThere is an R package out there\nthat makes it just as easy _not_ to hardcode\ncredentials into scripts.  That package\nis [`keyring`](https://keyring.r-lib.org/index.html)!\n\nLet's take a look.\n\n\n### Installing `keyring`\n\nI prefer to use `pak` to install R packages, so I will often install that first and then use it to install the desired packages.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"pak\")\n# pak::pak(\"keyring\")\n\nlibrary(keyring)\n```\n:::\n\n\n\n\n### Putting `keyring` into practice\n\n`keyring` stores credentials using the default credential\nmanager for your operating system. `keyring` makes interacting with\nthat manager, inside of your code, fairly seamless.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# keyring can be run interactively with pop ups\n# or you set the values in code - execute the code\n# and then remove those lines if anything is going to be saved\n\n# save some useful credentials\nkey_set_with_value(\n  service = \"my-service\",\n  username = \"my-username\",\n  password = \"my-super-secret-password-SSSHHHH\"\n)\n\n# interactively - you would call `key_set(\"my-service\")`\n# and fill in the details in the pop up.\n```\n:::\n\n\n\n::: {.callout-important}\n    Remember - you're just executing the code and not saving the\n    plain text password or senstive information in the code in a real world situation.\n:::\n\nNow how would we access those credentials for later use?\nThe `service` and `username` previously entered becomes the \nidentifiers used to pull the credential back into your environment.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# if you happen to forget your services\n# you can list them all out!\nkeyring::key_list()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     service    username\n1 my-service my-username\n```\n\n\n:::\n:::\n\n\n\nNotice how the usernames are listed alongside the service?\nUsers should be aware of that if they do not want usernames\nshowing up in the console output. However, we'll exploit\nthat functionality later on.  All a logged in user needs to \nretrieve a credential is a service name and a username. \n\n:::{.callout-caution}\n  Typically keyrings are set per user and are thus subject to \n  whatever security is employed around the user account.  It is imperative\n  that users take care to secure their accounts, otherwise\n  one compromised account can quickly spill over into others.\n:::\n\nLet's grab that credential now.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkey_get(service = \"my-service\", username = \"my-username\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"my-super-secret-password-SSSHHHH\"\n```\n\n\n:::\n:::\n\n\n\nSo the code above just prints straight to console - still not exactly \nwhat you would want in real life but now that can be saved to\nan object and used just about anywhere. \n\n\n### Examples\n\nLet's walk through some plausible examples:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remember - interactively we'd be using key_set(\"<service name here>\")\n\nkey_set_with_value(\n  service = \"open data portal\",\n  username = \"me@asenetcky.dev\",\n  password = \"mytotallyrealpassword123\"\n)\n\n# sometimes you just want to use the service name\n# and the password - and the \"password\" may\n# not even be a password per se.\n\nkey_set_with_value(\n  service = \"definitely real sql server connection string\",\n  password = \"127.0.0.1\"\n)\n```\n:::\n\n\n\n\n### Helper Functions\n\nKeyring works great for little private/internal helper functions and packages\nthat you might write or contribute to in your line of work. \nWhy not wrap a helper function around some keyring functionality?\n\n:::{.callout-note}\nI am using `renv` - for dependency management and I think you should *too* but that can be the topic of another post.\nI am going to assume the reader is not using `renv` and list the libraries - but I may miss one\nbecause `renv` has spoiled me.  Be sure to check our [`renv`](https://rstudio.github.io/renv/articles/renv.html) and \nits excellent documentation.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pak::pak(\n#   c(\n#     \"dplyr\", # for tidyverse data manipulations\n#     \"purrr\", # for funtional programming - and in our example, error catching\n#     \"glue\", # for easy formatted strings\n#     \"checkmate\", # for common checks in functions\n#     \"rlang\" # great for core language helpers\n#   )\n# )\n\n# if we use `renv` and don't mind using the full function name - package::function\n# you can avoid these library statements entirely.\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(rlang)\nlibrary(glue)\nlibrary(checkmate)\n```\n:::\n\n\n\nOur dependencies are set up - I'll use the full function names so\nthat there will be no ambiguity about what function comes from where.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnab_service_cred <- function(service_name) {\n  # check user input\n  # `checkmate` is great to testing function input\n  # and/or putting together unit tests in packages\n  checkmate::assert_character(service_name)\n\n  # handle global bindings\n  service <- username <- NULL\n\n  # grab email\n  email <-\n    keyring::key_list() |>\n    dplyr::filter(service == service_name) |>\n    dplyr::pull(username)\n\n  # throw error if empty\n  if (purrr::is_empty(email)) {\n    rlang::abort(\n      glue::glue(\"service: '{service_name}' - credential not found\")\n    )\n  }\n\n  # grab password\n  password <-\n    keyring::key_get(\n      service = service_name,\n      username = email\n    )\n\n  # return a named list\n  dplyr::lst(\n    email,\n    password\n  ) |>\n    # probably best to return\n    # invisibily in case of unintended prints\n    invisible()\n}\n```\n:::\n\n\n\nThis little helper can be a building block for other\nfunctionality in your scripts or package.  Maybe\nyou have a process upstream that handles errors\nelegantly - you can then wrap this up in\n`purrr::safely()` and then handle potential errors\nat your convenience. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsafer_nab <- purrr::safely(\n  nab_service_cred,\n  # set some default or placeholder values in case of errors\n  otherwise = dplyr::lst(\n    email = \"default-or-fake@email.com\",\n    password = \"default-or-fake-password.com\"\n  )\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# test it out\nresults <- safer_nab(\"not-a-service\")\nresults$result\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$email\n[1] \"default-or-fake@email.com\"\n\n$password\n[1] \"default-or-fake-password.com\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# the show goes on!\n# but if we want to see the error - we still can.\nresults$error$message\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nservice: 'not-a-service' - credential not found\n```\n\n\n:::\n\n```{.r .cell-code}\n# look there is our error message!\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# what about our service from before?\nresults <- safer_nab(\"open data portal\")\nresults\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$result\n$result$email\n[1] \"me@asenetcky.dev\"\n\n$result$password\n[1] \"mytotallyrealpassword123\"\n\n\n$error\nNULL\n```\n\n\n:::\n:::\n\n\n\nPlease keep in mind that `keyring` is very local\nto the user, and computer they are using.  It is\nnot a replacement for some more heavyweight solutions.\nHowever, it doesn't cost users anything to use, \nit's licensed under the permissive MIT license so\nit can generally be incorporated into codebases, and it\nis easy to use and readily available. So \nfor simple setups and/or simple projects I cannot\nreally think of a reason *not* to use it.\n\nHopefully these examples highlight how keyring can\nbe a great tool to bolster security around credential\nhandling in code, as well as a building block for\nhelper functions that can get your team on the\nsame page with connections, databases, service\naccounts and other credentials.\n\n### Cleaning up\n\nNow we have all these fake services and credentials in \nour operating system's credential manager. How do \nuser clean it all up?  `keyring` has tools for that\nas well.\n\nUsers can use `keyring::key_delete()` to wipe out \ncredentials they no longer want stored.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# jog our memories about the services...\nkeyring::key_list()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                                       service         username\n1 definitely real sql server connection string                 \n2                             open data portal me@asenetcky.dev\n3                                   my-service      my-username\n```\n\n\n:::\n\n```{.r .cell-code}\n# oh yeah - these ones.\n\ndplyr::lst(\n  \"my-service\",\n  \"open data portal\",\n  \"definitely real sql server connection string\"\n) |>\n  # let's borrow from our helper function\n  # I'm feeding the service names into our helper function\n  # so we can keep the service name and the email needed\n  # for the deletion in `purr::walk()`\n  purrr::map(\n    \\(serv) {\n      cred <- nab_service_cred(serv)\n      cred$name <- serv\n      cred\n    }\n  ) |>\n  purrr::walk(\n    \\(cred) {\n      name <- purrr::pluck(cred, \"name\")\n      email <- purrr::pluck(cred, \"email\")\n      keyring::key_delete(service = name, username = email)\n    }\n  )\n\nkeyring::key_list()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] service  username\n<0 rows> (or 0-length row.names)\n```\n\n\n:::\n:::\n\n\n\n## Your turn\n\nIf you haven't already, check out `keyring` and see what \nuse cases you can come up with. ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}