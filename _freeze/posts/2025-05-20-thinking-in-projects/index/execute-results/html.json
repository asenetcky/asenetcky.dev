{
  "hash": "87fd26db0905cec614cfdcc2f06668f4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Thinking in Projects\"\nsubtitle: \"Using `fs` and friends\"\ndescription: \"Increasing Portability and Reproducibility\"\ndate: 05-20-2025\ncategories: [R, R-Package, Developer-Toolkit, Developer-Mindset] \ncitation: \n    url: https://asenetcky.dev/using-projects\ndraft: true \n---\n\n## The Premise\n\nHow many times have you seen this at the top of an R script that was shared \nwith you by a friend or colleague?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetwd(\"~/some/path/not/on/your/computer/\")\n\nfoo <- function() {\n  print(\"AHHHH I NEED THIS TO WORK I HAVE A DEADLINE\")\n}\n\nfoo()\n```\n:::\n\n\nYou need that script to run - but it just blows up spectacularly in your face. \nYou go in to change that line and then the script works, or it doesn't. \nI find - more often than not - that if there is a `setwd()` at the top of a\nscript, that even if I correct the path there are other depedencies that did\nnot come along for the ride.\n\nWhen I started out learning R I did this alot. I still see this quite often.\nI see it from folks who have also moved well beyond the basics of R.  There is\nnothing wrong with using `setwd()` or `getwd()`.  However, I find that it is\nusually a signal that folks might not be thinking holistically about their code\nand the greater ecosystem in which it exists.  Reproducibility might not\nalways be on the forefront of everyone's minds, and look, I get it - sometimes\nyou just need to slap something together to solve a problem so you never have\nto think about it again. For all the other times (and I'd argue even for those\njust-get-it-done-times) this might be one of those rare moments where doing the\nmore robust thing is also the easier thing to do.\n\nThe road to reproducibility winds ever onward, and while there are many facets\nto making your code more reproducible, one of the easiest just about anyone\ncan adopt is a simple reframing of how we perceive our code.\n\n> Our code is a project.\n\nEven our small, simple little script is a project, inside of a what I'll\ncall *project-space*.  I'll define what I mean by *project* and *project-space*\nand how you can use these mental costructs to think about your code. Also,\nif you can afford to add another package dependency and you are programmatically\nworking with the file system I think the R package `fs` is worth taking a look\nat.\n\n## Defining *Project* and *Project-Space*\n\nI'm using the these terms broadly to cast a wide net. Your Integrated \nDevelopment Environment (IDE) may have a very concrete concept of a project\nor some kind of workspace or the folder you are working in.  You should \n100% take advantage of those quality of life features, however I am being a\nlitte more meta than that. Your code, your logic was created to tackle a\nproblem. This is your project, *your solution*.\n\n> Ideally this solution has everything it needs to stand alone\n\nIf it can stand alone, you can confidently pass it along to a teammate.\nWhen users hardcode a file path at the top of the script, their computer \n*at that point in time*  intrinsically becomes a part of that solution. \n\n> *You* are not a project.\n\nIt is up to the developer to divorce themselves from the project. It needs to\nbe self-contained. There are many ways of doing this and a great deal\nof tooling has spring up around divorcing the project from the user and the\nmachine the project was written on. It's also a spectrum too.  You need to be\nrealistic with yourself and your deadlines.  If R packages are all the way on\n\"reproducible\" end of the spectrum - you may not have time for that level\nof commitment, so you do what you can and aim to ship easy wins and build up\nto the ideal in time.\n\nSo what are these easy wins? You can make code soultion aware of its\nsurroundings. This is where *project-space* comes into play.\nYes, your code physically exists on your machine. You are possibly staring at\none or more projects on your machine.  But you need to think beyond your\nmachine.  These projects can and should be able (to the best of your abilities)\nexist on any number of machines.  \nIf you are tackling a business problem for work - you should strive to be able\nto have your code run just about anywhere at work should something catastrophic\nhappen to your usual work computer. *project-space* is a way of thinking\nabout your code being everywhere and nowhere and tackling the problems in your\ncode in the most person-environment agnostic ways possible.\n\n## The Easy Win\n\nUsing [`fs`](https://fs.r-lib.org/) will help to think about, and \nprogrammatically interact with your project-space.  It's a wonderful\npackage for working with files, folders and paths. The package is well\norganized and has consistant names that make finding functionality\nwithin the package a breeze. \n\n## Why fs over base?\n\nIt's spelled out better than I can ever state it in the \n[documentation](https://fs.r-lib.org/articles/function-comparisons.html).\n\nThe tl;dr is consistancy is king, and I cannot overstate that enough.\nIf you can confidently tell what the code is going to do by just reading it.\nThen your teammates are more likely to tell what that code is going to do\nby just reading it, and they will thank you for it.\n\n## Diving in\n\nConstructing paths with `fs` is easy!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# few different ways, you can mix and match\nfs::path(\"folder\", \"subfolder\", \"file\", ext = \"R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfolder/subfolder/file.R\n```\n\n\n:::\n\n```{.r .cell-code}\nfs::path(\"folder/subfolder/file.R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfolder/subfolder/file.R\n```\n\n\n:::\n\n```{.r .cell-code}\nfile_name <- \"my_file\"\nmy_path <-\n  fs::path(\"folder/subfolder\", file_name, ext = \"csv\")\n```\n:::\n\n\n\n\n### some context\n\nI often find that new R users in my line of work don't organize their\nwork into distinct projects.  If they use the [Rstudio]() IDE\nthey aren't using rstudio projects with the `.Rproj` files or\nworkspaces in other IDEs. Using `git` will often force the\nuse of project folders or at least the mindset of one, but\noften git isn't in use either.\n\nI found that, while working in public health during a pandemic\nthat anything I may have produced in code - no matter how many times\nit was relayed to me that the ask was \"a one-time thing\" - will\nlive on forever whether you want it to or not. If it provided \nsome value, and even if it didn't, it became familiar and \neventually took on a life all its own.\nThis is probably true in many other fields - so do yourself a favor\nand make sure whatever it is you build is something that\nisn't going to haunt you. Use `git` if you're able, and \nif not work in projects to organize your work. It may\nnot seem like setting up a project is worth it for\na quick todo - but if the ask is worth doing at all,\nsetup a project however your IDE of choice expects it.\nIt will become second nature and so fast that the\nheadaches they solve down the road will more than\nmake up for the short amount of time learning \nand setting them up.\n\n### benefits of project spaces\n\nSo what are these benefits?  Most of the time\nsome background quality of life magic is happening.\nIn the case of Rstudio - the scripts are \"aware\" of\nwhere they are so you usually no longer have use `setwd()` or\n`getwd()`.  Project level settings can also be saved to\nthe project space. I think the biggest benefit of all\nis a shift in your own mindset.\n\nwhat is that shift? I don't know what to call it\nso I'm making it up right now - \"the zen of projects\".\nI probably read something like this somewhere and forgot\nthat this isn't my own idea. So I am so sorry if this is\nsomeone else's idea. I am not trying to pass it off as my own.\nIf there are other related articles, or there is one \nwhere inadvertantly took that name from please reach out to me.\nI will link them all here!\n\nWhat is the \"zen of projects\"? You start to think about your\nwork as tiny little ecosystems, a functioning unit of work, not as a single script.\na collection of scripts and all the things you need to for your work to....well, *work*.\nMy mind instantly flashes back to all the organelles inside of a cell \nthe mitochondria, the nucleous and all the other things I've completely\nforgotten about until I wrote that very sentence above. I think `git` \nhelps you get into this mindset most of all because you want folks\nto be able to clone or fork your source code and be able to have it work.\n\nSome of this might seem obvious to those in a more traditional\ndeveloper role in a more traditional developer job - but Git use is almost \nnon-existent in my area of work. I *almost never* get a `README.md` or other\nrelevant documentation.\nCode isn't thought about much other than as a means to an end in the *now*, \nand not a second thought is paid to the *future*.\n\nSo this is for my friends in public health and in government. \nI want to focus on the biggest gains for the least amount of effort. Incorporating\na project space is easy to do, becomes natural and gets folks into\nthis project zen that will hopefully get folks to start thinking about code reproducibility\nand portability.\n\n\n## why fs over base\n\nIt's spelled out right \n[here](https://fs.r-lib.org/articles/function-comparisons.html).\n\nBut the tl;dr is consistancy is king TODO....\n\n### Why not `here`?\n\n`fs` and `here` may overlap a little bit with `fs::path_wd()` and `here::here()`\nbut the focus of the packages is completely different. `here` is all about\nproject directory roots and `fs` has a little bit of that but the focus\nis really on working in a file system on your computer.\n\nAlso, I wanted quick easy wins and I think `fs` with its `fs::path_wd()` is just\neasier to use for most usecases. I think the `here` package is fantastic and \nthose couple of extra [steps](https://here.r-lib.org/articles/here.html)\n***will*** be necessary some of the time. `here` has really saved my bacon in\nthe past and you should absolutely know about it.  Most of the time though,\n`fs::path_wd()` is *good enough*.\n\n## use projects but take nothing for granted\n\nSo I went on that whole big thing about using projects, but here is the kicker,\ntake nothing for granted. Use absolute file paths without hardcoding absolute file paths.\n\nbut how? use `fs` and friends.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"pak\")\n# pak::pak(\"fs\")\n```\n:::\n\n\n<!-- run in a container for final render & freeze -->\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(fs)\n\npath_home()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n/home/alex\n```\n\n\n:::\n\n```{.r .cell-code}\npath_wd()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n/home/alex/r-projects/asenetcky.dev/posts/2025-05-20-thinking-in-projects\n```\n\n\n:::\n\n```{.r .cell-code}\ndir_tree(path_wd())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n/home/alex/r-projects/asenetcky.dev/posts/2025-05-20-thinking-in-projects\n├── index.qmd\n└── index.rmarkdown\n```\n\n\n:::\n:::\n\n\n\ntodo next steps\nuse tree\nshow this little folder with tree\n\nTODO:\n`here` is great - but less set it and forget - but you'll likely need in projects\nwith nested folders that use quarto or rmarkdown etc...\n\n## the end part\n\nWhere to go from here? \n- renv\n- git & repos\n- template repos\n- containers\n\n\nSo what about you? What have you picked up along the way\nin your career that you would want new folks starting out\nto know?  Anything you picked up from another field, or\neven another programming language that your brought with\nyou to all your projects in other languages?",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}