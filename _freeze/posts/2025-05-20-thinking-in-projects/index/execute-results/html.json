{
  "hash": "9f1d01a68dcf0be886f12f96daf5e275",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Thinking in Projects\"\nsubtitle: \"Using `fs` and friends\"\ndescription: \"Increasing Portability and Reproducibility\"\ndate: 05-20-2025\ncategories: [R, R-Package, Developer-Toolkit, Developer-Mindset] \ncitation: \n    url: https://asenetcky.dev/using-projects\ndraft: false \n---\n\n## The Premise\n\nHow many times have you seen this at the top of an R script that was shared \nwith you by a friend or colleague?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetwd(\"~/some/path/not/on/your/computer/\")\n\nfoo <- function() {\n  print(\"AHHHH I NEED THIS TO WORK I HAVE A DEADLINE\")\n}\n\nfoo()\n```\n:::\n\n\nYou need that script to run - but it just blows up spectacularly in your face. \nYou go in to change that line and then the script works, or it doesn't. \nI find - more often than not - that if there is a `setwd()` at the top of a\nscript, that even if I correct the path there are other dependencies that did\nnot come along for the ride.\n\nWhen I started out learning R I did this alot. I still see this quite often.\nI see it from folks who have also moved well beyond the basics of R.  There is\nnothing wrong with using `setwd()` or `getwd()`.  However, I find that it is\nusually a signal that folks might not be thinking holistically about their code\nand the greater ecosystem in which it exists.  Reproducibility might not\nalways be on the forefront of everyone's minds, and look, I get it - sometimes\nyou just need to slap something together to solve a problem so you never have\nto think about it again. For all the other times (and I'd argue even for those\njust-get-it-done-times) this might be one of those rare moments where doing the\nmore robust thing is also the easier thing to do.\n\nThe road to reproducibility winds ever onward, and while there are many facets\nto making your code more reproducible, one of the easiest just about anyone\ncan adopt is a simple reframing of how we perceive our code.\n\n> Our code is a project.\n\nEven our small, simple little script is a project, inside of a what I'll\ncall *project-space*.  I'll define what I mean by *project* and *project-space*\nand how you can use these mental costructs to think about your code. Also,\nif you can afford to add another package dependency and you are programmatically\nworking with the file system I think the R package `fs` is worth taking a look\nat.\n\n## Defining *Project* and *Project-Space*\n\nI'm using the these terms broadly to cast a wide net. Your Integrated \nDevelopment Environment (IDE) may have a very concrete concept of a project\nor some kind of workspace or the folder you are working in.  You should \n100% take advantage of those quality of life features, however I am being a\nlitte more meta than that. Your code, your logic was created to tackle a\nproblem. This is your project, *your solution*.\n\n> Ideally this solution has everything it needs to stand alone\n\nIf it can stand alone, you can confidently pass it along to a teammate.\nWhen users hardcode a file path at the top of the script, their computer \n*at that point in time*  intrinsically becomes a part of that solution. \n\n> *You* are not a project.\n\nIt is up to the developer to divorce themselves from the project. It needs to\nbe self-contained. There are many ways of doing this and a great deal\nof tooling has spring up around divorcing the project from the user and the\nmachine the project was written on. It's also a spectrum too.  You need to be\nrealistic with yourself and your deadlines.  If R packages are all the way on\n\"reproducible\" end of the spectrum - you may not have time for that level\nof commitment, so you do what you can and aim to ship easy wins and build up\nto the ideal in time.\n\nSo what are these easy wins? You can make code soultion aware of its\nsurroundings. This is where *project-space* comes into play.\nYes, your code physically exists on your machine. You are possibly staring at\none or more projects on your machine.  But you need to think beyond your\nmachine.  These projects can and should be able (to the best of your abilities)\nexist on any number of machines.  \nIf you are tackling a business problem for work - you should strive to be able\nto have your code run just about anywhere at work should something catastrophic\nhappen to your usual work computer. *project-space* is a way of thinking\nabout your code being everywhere and nowhere and tackling the problems in your\ncode in the most person-environment agnostic ways possible.\n\n## The Easy Win\n\nUsing [`fs`](https://fs.r-lib.org/) will help to think about, and \nprogrammatically interact with your project-space.  It's a wonderful\npackage for working with files, folders and paths. The package is well\norganized and has consistant names that make finding functionality\nwithin the package a breeze. \n\nInteracting with files and folders is great, but it's the function\n`fs::path_wd()` that I find myself using *all* the time.  You can basically\ndrop this function in your scripts and functions and it is probably going\nto handle 98% of your project-space pathing issues, with a few exceptions.\n\nLet's cover some basic concepts with `fs` before we finish with `fs::path_wd()`.\n\n## Why fs over base?\n\nIt's spelled out better than I can ever state it in the \n[documentation](https://fs.r-lib.org/articles/function-comparisons.html).\n\nThe tl;dr is that consistancy is king, and it really is. I cannot \nemphasize that enough.  Nobody likes hidden surprises, much less coming \nfrom your behind-schedule, tech-debt-ridden past self.\nIf you can confidently tell what the code is going to do by just reading it.\nThen your teammates are more likely to tell what that code is going to do\nby just reading it, and they will thank you for it.\n\n## Diving in\n\nYou'll be constructing alot of paths with `fs`, but thankfully\nthat is easy!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(fs)\n\n# few different ways, you can mix and match\npath(\"folder\", \"subfolder\", \"file\", ext = \"R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfolder/subfolder/file.R\n```\n\n\n:::\n\n```{.r .cell-code}\npath(\"folder/subfolder/file.R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfolder/subfolder/file.R\n```\n\n\n:::\n:::\n\n\nInspecting an `fs` path we'll see that it has it's own class `fs_path`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_name <- \"my_file\"\nmy_path <-\n  path(\"folder/subfolder\", file_name, ext = \"csv\")\n\nmy_path\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfolder/subfolder/my_file.csv\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(my_path)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"fs_path\"   \"character\"\n```\n\n\n:::\n:::\n\n\nSome bells and whistles come along for the ride, but you can mostly think\nof these as `characters` with some nice vectorized function friends. Now\nlet's look at some real files.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# let's create a temporary file\n\n# create the path\ntemp_file <- file_temp(ext = \"R\")\ntemp_file\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n/tmp/Rtmpz7YdwB/file8a2e435c77f7.R\n```\n\n\n:::\n\n```{.r .cell-code}\n# does it exist yet?\nfile_exists(temp_file)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n/tmp/Rtmpz7YdwB/file8a2e435c77f7.R \n                             FALSE \n```\n\n\n:::\n\n```{.r .cell-code}\n# create the file\nfile_touch(temp_file)\n\n# now does it exist?\nfile_exists(temp_file)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n/tmp/Rtmpz7YdwB/file8a2e435c77f7.R \n                              TRUE \n```\n\n\n:::\n:::\n\n\nLet's grab some info about this file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# we can programmatically grab all the pieces about this file and surroundings\n\n# the extension\npath_ext(temp_file)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"R\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# the directory\npath_dir(temp_file)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/tmp/Rtmpz7YdwB\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# file info\nfile_info(temp_file) |>\n  dplyr::select(\"block_size\") |>\n  fs::as_fs_bytes()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n4K\n```\n\n\n:::\n\n```{.r .cell-code}\n# list surroundings\npath_dir(temp_file) |>\n  dir_ls()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n/tmp/Rtmpz7YdwB/file8a2e435c77f7.R\n/tmp/Rtmpz7YdwB/libloc_171_2b363be77582bd8f.rds\n/tmp/Rtmpz7YdwB/libloc_238_3dec933b1be4517c.rds\n/tmp/Rtmpz7YdwB/libloc_245_3f803f276593ddff.rds\n```\n\n\n:::\n\n```{.r .cell-code}\n# or get a cool tree!\npath_dir(temp_file) |>\n  dir_tree()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n/tmp/Rtmpz7YdwB\n├── file8a2e435c77f7.R\n├── libloc_171_2b363be77582bd8f.rds\n├── libloc_238_3dec933b1be4517c.rds\n└── libloc_245_3f803f276593ddff.rds\n```\n\n\n:::\n:::\n\n\n\n### Kept you waiting, huh?\n\nLet's delete that file for now and move on to why we're here - `fs::path_wd()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# delete file\nfile_delete(temp_file)\n\n# and shift focus to where we are\nproject_path <- path_wd()\nproject_path\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n/home/alex/r-projects/asenetcky.dev/posts/2025-05-20-thinking-in-projects\n```\n\n\n:::\n:::\n\n\nDid you catch that?\nIt's subtle - and possibly underwhelming. The function knows where it is.\nWhat's more important is what it ***did not do*** - it did not mess with\nand change a user's project-space.  `setwd()` might be set to a path that\ndoes not exist and that is annoying, but at least it would fail fast. What \nif it didn't though? What if it silently set it some far off location\nand one part of your script works, but then the rest start throwing errors or\nclobbering file that should not be touched. \n\n`fs::path_wd()` uses the point of view from the script/function and separates\nthe user from the project and the project-space.  Now it doesn't matter - \nmore or less - where your drop your logic, it will pick up on its surroundings\nand execute commands.\n\nIt is also just so easy to drop `path_wd()` anywhere and save yourself some\ntyping.  If you have a deeply nested project you can use that to take care\nof some of the pathing boilerplate.\n\nWhat if I wanted to print the first few lines of code from another post?\nEasy.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# you can add the folders and files into path_wd()\npath_wd(\"file-that-is-definitely-here\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n/home/alex/r-projects/asenetcky.dev/posts/2025-05-20-thinking-in-projects/file-that-is-definitely-here\n```\n\n\n:::\n\n```{.r .cell-code}\n#  you can substitute path_wd() for our project_path object as well\npath(path_wd(), \"cool-folder\", \"possibly-more-complex-path\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n/home/alex/r-projects/asenetcky.dev/posts/2025-05-20-thinking-in-projects/cool-folder/possibly-more-complex-path\n```\n\n\n:::\n:::\n\n\n### Some Caveats\n\nIt's so easy to use, there really isn't a reason *not* to use it.\nExcept there is that last 2% of the time where you might not want to use\n`path_wd()` and that's usually when working with a program that shifts the\nworking directory, or at least, it's focus.  An example of that would be\n`Quarto` which is what I use to write this website and this very post.\nThe `project_path` we saved earlier - when I go to print that - the one\nI see in the notebook/console/terminal is not going to be the same path\nwhen the final document is rendered.  There are probably some other times\nwhen this happens - but that is the biggest one I encounter.  That's not\na failing of `fs` it's just that different tool altogether is taking the reins\nfor a bit. For something like that - you probably want to use the `here`\npackage.\n\n## So why not `here` all the time?\n\n`fs` and `here` may overlap a little bit with `fs::path_wd()` and `here::here()`\nbut the focus of the packages is completely different. `here` is all about\nproject directory roots and `fs` has a little bit of that but the focus\nis really on working in a file system on your computer.\n\nAlso, I wanted quick easy wins and I think `fs` with its `fs::path_wd()` is just\neasier to use for *most* usecases. I think the `here` package is fantastic and \nthose couple of extra [steps](https://here.r-lib.org/articles/here.html)\n***will*** be necessary some of the time. `here` has really saved my bacon in\nthe past and you should absolutely know about it.  Most of the time though,\n`fs::path_wd()` is *good enough*.\n\n## Being flexible but take nothing for granted\n\nSo what did we do here today? We learned that we can be both explicit\nin our pathing at run time - but flexible enough where we don't have to\nhardcode every path so that *only we* can run our code. We truly can have\nthe best of both worlds.\n\n`fs` is great for working within your filesystem, but it is also an \n**entrypoint** into thinking about your project in a broader, project focused \ncontext. \n\n### Where do we go from here?\n\nKeep practicing and building cool things of course! Really this \nproject-focused thinking is an introduction to starting to think reproducibly\nabout your code, your methods and your environment.  Some incredibly\nhelpful tools you might want to check out if you haven't are:\n\n- `renv`: An R package for dependency management - a game changer.\n- git and using repositories: Distributed version control software that really\ndrives home working in projects.\n- GitHub template repositories: If you have your projects setup how you like\nthem, why not make a blank template for yourself?\n- containers: If you haven't worked with these before - they'll blow your mind.\nRead up on Podman or Docker and see how these tackle \"well, it works on my\nmachine\" problem that we all encounter one way or another.\n\nSo what about you? What have you picked up along the way\nin your career that you would want new folks starting out\nto know?  Anything you picked up from another field, or\neven another programming language that your brought with\nyou to all your projects in other languages?",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}